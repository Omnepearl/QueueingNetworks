---
title: "Statistical Package for Queueing in R"
author: "University of Southern Maine"
date: "9/14/2021"
output:
  html_document: default
  word_document: default
  pdf_document: default
subtitle: Angyalka Valcsics, Pearl Armstrong, Shawn Houser
header-includes:
- \usepackage{placeins}
- \usepackage{bookends}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Queueing theory is the mathematical study of the formation and function of queues.  A basic queueing system is a system where entities arrive at a facility requiring some service, they join a line, and wait for service from one or more servers. The results of queueing analysis can be used to offer faster customer service, increase traffic flow, improve order shipments from a warehouse, or to design data networks and call centers. In this first demonstration, we will use the random events of arrivals and service completions from a general distribution to demonstrate the development of a queue over time. We assume the reader has some previous knowledge of queueing networks. 

## Measures of System Performance

Variable | Definition
------------- | -------------
$\lambda$  | Average arrival rate
$S$  | Random service rate
$\mu$  | Average service rate
$c$  | Number of servers
$r = \lambda / \mu$  | Offered load
$\rho = \lambda / c \mu$  | Traffic intensity or utilization
$T, T_{q}$  | Random time a customer spends in the system / queue
$W, W_{q}$  | Average time a customer spends in the system / queue
$N, N_{q}$  | Random number of customers in the system / queue
$L, L_{q}$  | Average number of customers in the system / queue

## Notation and relationships for G/G/1 queue

In event-oriented bookkeeping, the system state is only updated when events occur. Either when customers/jobs arrive or depart. Suppose we observe a system, recording the times of arrival and service for each entity. An alternative to recording arrival times is to record the time between arrivals. With this information we can calculate measures of performance (see table above) and find other bookkeeping results such as:

Variable | Definition | Sample relationship
------------- | ------------- | -------------
$A^{(n)}$  | Arrival time of cust. $n$ | 
$S^{(n)}$  | Service time of cust. $n$ |
$T^{(n)}$  | Inter. time cust. $n$ and $n+1$ | $T^{(n)} = A^{(n+1)} - A^{(n)}$
$U^{(n)}$  | Time cust. $n$ starts service | $U^{(n+1)} = max\{D^{(n)}, A^{(n+1)}\}$
$D^{(n)}$  |Departure time of cust. $n$ | $D^{(n)} = U^{(n)} + S^{(n)}$
$W_{q}^{(n)}$  | Time in queue of cust. $n$ | $W_{q}^{(n)} = U^{(n)} - A^{(n)}$
$W^{(n)}$  | Time in system of cust. $n$ | $W^{(n)} = W_{q}^{(n)} + S^{(n)}$

The analysis is obtained under the assumption of a single server with FCFS discipline. No assumptions are required on the probability laws for the interarrival times or service times. 

The gg1.summary() function takes three inputs. First an input of either the arrival times or the interarrival times, the service times, and a Boolean--set interarrival = TRUE if the first input is interarrival times. The function outputs a data frame with the bookkeeping values for each entity and a data frame which holds some performance measures.The user can access performance measures by name using the $ operator. Please see the examples that follow.

```{r gg1summayy, echo=FALSE }
gg1.summary <- function(arrivals, service_times, interarrival = FALSE){
   if(length(arrivals) != length(service_times))
   {
      stop('Arrays must have equal length')
   }
   n <- length(arrivals)
   if(interarrival == TRUE){
      interarrival_times = c(arrivals, NA)
      service_times = c(NA, service_times)
      arrival_times = c(0)
      arrival_times <- append(arrival_times, interarrival_times[1])
      for(i in 2:n){
         arrival_times <- append(arrival_times, arrival_times[i] + interarrival_times[i])
      }
      starts_service <- c(NA, arrival_times[2])
      departure_times <- c(NA, service_times[2] + arrival_times[2])
      for(i in 3:(n+1)){
         starts_service <- append(starts_service, max(departure_times[i-1], arrival_times[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- c(starts_service - arrival_times)
      system_times <- c(queue_times + service_times)
      df <- data.frame(customers = c(0, seq(1:n)), arrival_times = arrival_times,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times, na.rm = TRUE)
      W <- mean(system_times, na.rm = TRUE)
      lambda <- n/departure_times[n+1]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
             'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
      
   }
   else{
      interarrival_times <- c(diff(arrivals), NA)
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrivals[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrivals[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrivals
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrivals = arrivals,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
             'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
   
}
```

```{r ex1}
# Arrival times
arrival <- c(0, 2, 3, 6, 7, 8, 12, 14, 19, 20, 24, 26)
# Service times
service <- c(1, 3, 6, 2, 1, 1, 1, 2, 5, 1, 1, 3)
# Run gg1.summary() on this data
q <- gg1.summary(arrival, service)
# Use gt package for nice tables
library(gt)
# Get bookkeeping results
pt <- q$bookkeeping
pt %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

<br />
Now suppose that we only had data on the interarrival times and the service times. 

```{r ex2}
# Interarrival times
inter <- c(1, 9, 6, 4, 7, 9, 5, 8, 4, 10, 6, 12, 6, 8, 
           9, 5, 7, 8, 8, 7)
# Service times
serv <- c(3, 7, 9, 9, 10, 4, 8, 5, 5, 3, 6, 3, 5, 4, 
          9, 9, 8, 6, 8, 3)
# Run gg1.summary() on this data
q2 <- gg1.summary(inter, serv, interarrival = TRUE)
pt2 <- q2$bookkeeping
pt2 %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt2 <- q2$res
qt2 %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

<br />
Next we consider an M/M/1 Markovian model. Given inputs arrival rate, service rate, and number of servers $c = 1$ the function mm1.summary() returns a data frame of performance measures for the queue and an array of transition probabilities for the first 25 entities. Additionally, by entering "plot_transitions = TRUE", the function will plot these transition probabilities. The user can access performance measures by name using the $ operator. Please consider the following example. 

```{r mm1summayy, echo=FALSE }
mmc.summary <- function(lambda, mu, c, plot_transitions = FALSE){
   if(c == 1){
      rho = lambda/mu
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")
      }
      p_n = integer(26)
      for(iter in 1:26){
         p_n[iter] = (rho^iter)*(1-rho)
         iter = iter + 1
      }
      if(plot_transitions == TRUE){
         num_ent = c(0, 1:25)
         plot(num_ent, p_n, main="Transition Probabilities",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      L = rho/(1-rho)
      L_q = rho^2/(1-rho)
      W = 1/(mu - lambda)
      W_q = lambda/(mu*(mu - lambda))
      U = 1 - p_n[1]
      I = 1 - rho
      
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, I, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('transition_prob' = p_n, 'res' = res, 'lambda' = lambda, 'rho' = rho, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
   else{
      print("c = ?")
   }
   return(1)
}
```

```{r ex3}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 1, plot_transitions = TRUE)

library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/1 Queues"))
```

<br />
Using the output we can find the probability that there are more than $k$ entities in the system using the formula $P(X \geq k) = \rho^{k}$. Suppose we wanted to find the probability that there are more than $k = 2$ entities in the system.

```{r ex4}
k = 2
prob_k_system <- (q$rho)^k
print(prob_k_system)
```

Moreover, we could find the probability that an entity spends more than some time $t$ in the queue $P(T_{q} > t) = \rho e^{- \mu (1 - \rho)t}$. Suppose $t = 0.05$.

```{r ex5}
t = 0.05
mu = 4.4545
rho = q$rho
prob_t_queue <- rho*exp(-mu*(q$p0)*t)
print(prob_t_queue)
```










