---
title: "Statistical Package for Queueing Networks in R"
author: "University of Southern Maine"
date: "9/14/2021"
output:
  html_document: default
  pdf_document: default
subtitle: Angyalka Valcsics, Pearl Armstrong, Shawn Houser
header-includes:
- \usepackage{placeins}
- \usepackage{bookends}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Pearl--add a nice intro? "we assume previous knowledge of queueing networks yada yada yada"

## Measures of System Performance

Variable | Definition
------------- | -------------
$\lambda$  | Average arrival rate
$S$  | Random service rate
$\mu$  | Average service rate
$c$  | Number of servers
$r = \lambda / \mu$  | Offered load
$\rho = \lambda / c \mu$  | Traffic intensity or utilization
$T, T_{q}$  | Random time a customer spends in the system / queue
$W, W_{q}$  | Average time a customer spends in the system / queue
$N, N_{q}$  | Random number of customers in the system / queue
$L, L_{q}$  | Average number of customers in the system / queue

## Notation and relationships for G/G/1 queue

In event-oriented bookkeeping, the system state is only updated when events occur. Either when customers/jobs arrive or depart. Suppose we observe a system, recording the times of arrival and service for each entity. An alternative to recording arrival times is to record the time between arrivals. With this information we can calculate measures of effectiveness (see table above) and find other bookkeeping results such as:

Variable | Definition | Sample relationship
------------- | ------------- | -------------
$A^{(n)}$  | Arrival time of cust. $n$ | 
$S^{(n)}$  | Service time of cust. $n$ |
$T^{(n)}$  | Interarrival time cust. $n$ and $n+1$ | $T^{(n)} = A^{(n+1)} - A^{(n)}$
$U^{(n)}$  | Time cust. $n$ starts service | $U^{(n+1)} = max\{D^{(n)}, A^{(n+1)}\}$
$D^{(n)}$  |Departure time of cust. $n$ | $D^{(n)} = U^{(n)} + S^{(n)}$
$W_{q}^{(n)}$  | Time in queue of cust. $n$ | $W_{q}^{(n)} = U^{(n)} - A^{(n)}$
$W^{(n)}$  | Time in system of cust. $n$ | $W^{(n)} = W_{q}^{(n)} + S^{(n)}$

The analysis is obtained under the assumption of a single server with FCFS discipline. No assumptions are required on the probability laws for the interarrival times or service times. 

The gg1.summary() function takes three inputs. First an input of either the arrival times or the interarrival times, the service times, and a Boolean--set interarrival =TRUE if the first input is interarrival times. The function outputs a data frame with the bookkeeping values for each entity and a data frame which holds the effectiveness measures. Please see the example that follows.

```{r gg1summayy, echo=FALSE }
gg1.summary <- function(arrivals, service_times, interarrival = FALSE){
   if(length(arrivals) != length(service_times))
   {
      stop('Arrays must have equal length')
   }
   n <- length(arrivals)
   if(interarrival == TRUE){
      interarrival_times = arrivals
      arrival_times = c(0)
      arrival_times <- append(arrival_times, interarrival_times[1])
      for(i in 2:(n-1)){
         arrival_times <- append(arrival_times, arrival_times[i] + interarrival_times[i])
      }
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrival_times[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrival_times[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrival_times
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrival_times = arrival_times,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      eff <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(eff)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'eff' = eff))
      
   }
   else{
      interarrival_times <- c(diff(arrivals), NA)
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrivals[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrivals[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrivals
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrivals = arrivals,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      eff <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(eff)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'eff' = eff))
   }
   
}
```

```{r ex1}
# Arrival times
arrival <- c(0, 2, 3, 6, 7, 8, 12, 14, 19, 20, 24, 26)
# Service times
service <- c(1, 3, 6, 2, 1, 1, 1, 2, 5, 1, 1, 3)
# Run gg1.summary() on this data
res <- gg1.summary(arrival, service)
# Use gt package for nice tables
library(gt)
# Get bookkeeping results
pt <- res$bookkeeping
pt %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get effectiveness results
qt <- res$eff
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Effectiveness for G/G/1 Queues"))

```

Now suppose that we only had data on the interarrival times and the service times. 

```{r ex2}
# Interarrival times
inter <- c(1, 9, 6, 4, 7, 9, 5, 8, 4, 10, 6, 12, 6, 8, 
           9, 5, 7, 8, 8, 7)
# Service times
serv <- c(3, 7, 9, 9, 10, 4, 8, 5, 5, 3, 6, 3, 5, 4, 
          9, 9, 8, 6, 8, 3)
# Run gg1.summary() on this data
res2 <- gg1.summary(inter, serv, interarrival = TRUE)
pt2 <- res2$bookkeeping
pt2 %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get effectiveness results
qt2 <- res2$eff
qt2 %>%
   gt() %>%
   tab_header(
      title = md("Measures of Effectiveness for G/G/1 Queues"))

```


